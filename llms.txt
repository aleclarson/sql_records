# sqlite_records: Minimal, Type-Safe SQL Wrapper for Dart 3

## Overview
`sqlite_records` is a functional, minimal wrapper for SQLite (PowerSync) and PostgreSQL that leverages Dart 3 Records for compile-time parameter type safety and "best-effort" runtime result validation. It prioritizes a "declare-what-you-use" strategy, ensuring that SQL and its mapping logic are co-located.

## Key Features
- **Multi-Engine Support**: Choose between SQLite (via PowerSync) or PostgreSQL.
- **Record-Based Parameters**: Use Dart Records to define query parameters, getting compile-time safety at the call site.
- **Schema-Aware Results**: Explicitly define expected result schemas using standard Dart types.
- **SafeRow Access**: Access row data with `get<T>`, `getOptional<T>`, and `parse<T, DB>`, catching schema or type drift immediately.
- **Reactive Queries**: Built-in support for `watch` to receive streams of result sets (PowerSync only).
- **Batch Operations**: Efficient `executeBatch` for bulk mutations.
- **Zero Boilerplate**: No code generation or complex ORM configuration required.

## Installation
The library depends on `powersync`, `sqlite3`, `sqlite_async`, and `postgres`. Ensure these are in your `pubspec.yaml`.

## Core Concepts

### 1. Defining Queries and Commands
Queries and Commands encapsulate the SQL, the parameter mapping, and a "result token" (a Record type used for documentation and potential linting).

#### `Query<P, R>` (Reads)
- **P**: The parameter Record type (e.g., `({String status})`).
- **R**: The expected result Record type (e.g., `({String name, int age})`).
- **schema**: A `Map<String, Type>` defining the expected types of columns in the result set.
- **params**: A mapper function or a map literal.

```dart
final activeUsersQuery = Query<({String status}), ({String name, int age})>(
  'SELECT name, age FROM users WHERE status = @status',
  params: (p) => {'status': p.status},
  schema: {'name': String, 'age': int},
);
```

#### `Command<P>` (Mutations)
Used for `INSERT`, `UPDATE`, and `DELETE`.

```dart
final updateUserCommand = Command<({String id, String name})>(
  'UPDATE users SET name = @name WHERE id = @id',
  params: (p) => {'id': p.id, 'name': p.name},
);
```

#### Dynamic Commands (Patching)
Specialized `Command` subclasses that generate SQL dynamically.

- **`UpdateCommand<P>`**: Generates an `UPDATE` statement, skipping any `null` values.
- **`InsertCommand<P>`**: Generates an `INSERT` statement using only non-null values.

### 2. Initialization

```dart
// SQLite / PowerSync
final db = SqlRecords.fromPowerSync(powersyncDb);

// PostgreSQL
final db = SqlRecords.fromPostgres(postgresSession);
```

### 3. Executing Queries

#### `getAll`, `get`, `getOptional`
Returns `SafeResultSet<R>` or `SafeRow<R>`.

```dart
final rows = await db.getAll(activeUsersQuery, (status: 'active'));
for (final row in rows) {
  final name = row.get<String>('name');
}
```

### 4. Executing Mutations

#### `execute`
Executes a command and returns a `MutationResult`.

```dart
final result = await db.execute(updateUserCommand, (id: '123', name: 'New Name'));
print('Rows affected: ${result.affectedRows}');
```

#### `executeBatch`
Efficiently executes a command multiple times.

### 5. Transactions

- `readTransaction`: Provides `SqlRecordsReadonly` context.
- `writeTransaction`: Provides `SqlRecords` context.

### 6. SafeRow & Data Parsing
`SafeRow` wraps the raw database row and enforces the schema.

- `row.get<T>(key)`: Type-safe, non-nullable access.
- `row.getOptional<T>(key)`: Type-safe, nullable access.
- `row.parse<T, DB>(key, parser)`: Custom parsing logic.

## Caveats & Troubleshooting
- **Named Parameters**: Use the `@name` syntax.
- **Postgres ID**: `MutationResult.lastInsertId` is always `null` for Postgres unless using `RETURNING` clauses in the query.
- **Watch**: `watch()` is currently only supported for PowerSync.
